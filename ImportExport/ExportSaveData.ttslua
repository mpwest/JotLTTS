#include DataExportInfo
#include ExportTypes

maxSourceVersion = 2
white = color(1,1,1,1)
green = color(76/255, 177/255, 71/255, 1)
blue = color(31/255, 136/255, 255/255, 1)

saveState = {}

function onLoad(save_state)
    if save_state ~= nil then
        saveState = JSON.decode(save_state)
    end

    if saveState == nil then saveState = {} end

    if saveState['complete'] ~= nil and saveState['complete'] then
        self.setColorTint(green)
        tryPushSaveData()
    else
        local version = getVersion()
        if saveState['sourceVersion'] == nil or version == saveState['sourceVersion'] then
            saveState['sourceVersion'] = version
            requestSaveData(version)
        else
            broadcastToAll('This save token has begun exporting data from a different version of this mod. Please spawn a new instance of the save token from the target version and choosing \'Expand\'.', white)
        end
    end
end

function getVersion()
    if Global.getVar('getVersion') then
        return Global.call('getVersion')
    end
    -- version 1 and 2 can be differentiated by presence of Gloomhaven character boxes
    local bruteTuckBoxGUID = '7dfec2'
    if getObjectFromGUID(bruteTuckBoxGUID) ~= nil then
        return 2
    else
        return 1
    end
end

function tryPushSaveData()
    if Global.getVar('importPriorVersion') then
        broadcastToAll('Import from version ' .. saveState['sourceVersion'], {1,1,1,1})
        if Global.call('importPriorVersion', JSON.encode(saveState)) then
            selfDestruct()
        end
    end
end

function selfDestruct()
    flashSuccess(green)
    Wait.time(function() self.destruct() end, 1.25)
end

function requestSaveData(version)
    local next = saveState['next'] or 'CharacterInfoTile'
    local request = requestData[version][next]

    broadcastToAll(request.message, white)
end

function onCollisionEnter(collision_info)
    if saveState == nil or saveState['sourceVersion'] == nil  then -- collision event triggered before onLoad completed, ignore collision
        return
    end

    local next = saveState['next'] or 'CharacterInfoTile'
    local version = saveState['sourceVersion']
    local request = requestData[version][next]
    local target = collision_info['collision_object']

    if saveState['complete'] then
        return
    end

    if target.getName() == '' and target.tag == 'Tile' then -- presumably the ground, ignore collision. we don't do anything with unnamed tiles anyways
        return
    end

    -- fix this for non-skippable types
    if target.getName() == 'NEXT' and target.getGMNotes() == 'Continue export data process' then
        saveState['next'] = request.next or request.continueOrNext or saveState['next']
        requestSaveData(version)
        return
    end

    if checkValidTarget(target, saveState['sourceVersion'], next) then
        self.call('export' .. next, {target = target, version = saveState['sourceVersion']})
        saveState['next'] = request.continue or request.continueOrNext
        if saveState['next'] == 'Done' then
            complete()
        else
            flashSuccess(blue)
            requestSaveData(version)
        end
    end

    save()
end

function checkValidTarget(target, version,  next)
    local type = target.tag
    if not checkType(type, validTypeData[version][next].type) then return false end
    if not checkName(target, validTypeData[version][next].name) then return false end
    if not checkMinMax(target, validTypeData[version][next].min, validTypeData[version][next].max) then return false end

    return true
end

function checkType(type, possibleTypes)
    for _, typeOption in pairs(possibleTypes) do
        if type == typeOption  then
            return true
        end
    end
    return false
end

function checkName(target, expectedNames)
    local possibleNames = ''
    local foundName = false
    if expectedNames then
        for _, matchName in pairs(expectedNames) do
            if target.getName() == matchName then
                return true
            else
                possibleNames = possibleNames .. ' '.. matchName
            end
        end
        broadcastToAll('Expected an item with name:' .. possibleNames, {1,1,1,1})
    else
        return true
    end
end

function checkMinMax(target, min, max)
    if target.tag ~= 'Deck' and target.tag ~= 'Bag' then
        if min ~= nil and min > 1 then
            return false
        else
            return true
        end
    end

    if min then
        if #(target.getObjects()) < min then
            broadcastToAll('Expected a deck with at least ' .. min .. ' cards', {1,1,1,1})
            return false
        end
    end

    if max then
        if #(target.getObjects()) > max then
            broadcastToAll('Expected a deck with at most ' .. max .. ' cards', {1,1,1,1})
            return false
        end
    end
    return true
end

function readCardsInDeck(deck, version, deckType)
    local mapSet = getMapSet(version, deckType)

    local cards = {}
    for _, card in pairs(deck.getObjects()) do
        table.insert(cards, mapSet[card.name] or card.name)
    end
    return cards
end

function readCard(card, version, deckType)
    local mapSet = getMapSet(version, deckType)
    return { mapSet[card.name] or card.name }
end

function getMapSet(version, cardType)
    if nameMapping[version] ~= nil and nameMapping[version][cardType] ~= nil then
        return nameMapping[version][cardType]
    end
    return {}
end

function flashSuccess(secondaryColor)
    Wait.time(function() self.setColorTint(secondaryColor) end, 0.25)
    Wait.time(function() self.setColorTint(white) end, 0.5)
    Wait.time(function() self.setColorTint(secondaryColor) end, 0.75)
    Wait.time(function() self.setColorTint(white) end, 1)
end

function complete()
    saveState['complete'] = true
    self.setColorTint(green)
    broadcastToAll(completeMessage, {1,1,1,1})
end

function save()
    self.script_state = JSON.encode(saveState)
end
